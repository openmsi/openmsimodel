import json
import networkx as nx
from collections import defaultdict
import shutil
import os
from gemd.util.impl import recursive_foreach
from gemd.json import GEMDJson

import matplotlib.pyplot as plt

# from matplotlib.lines import Line2D
# import matplotlib.colors as colors
# import matplotlib.cm as cmx
# import matplotlib.patches as mpatches
# from matplotlib import pylab
import argparse
import pathlib


# TODO: add flag to open visualization tool?
# TODO: add file links and tags
class GemdModeller:
    """this class provides modules to build and visualize a networkx or graphviz object from gemd objects.
    By taking folder path containing GEMD thin JSON files, it establishes the relationships
    between them by interpreting their uuids/links, and flexibly produces anything from
    a svg image with simple labels, to a dot products containing all the gemd assets,
    from attributes, file links or tags.
    """

    IPYNB_FILENAME = pathlib.Path(
        pathlib.Path(__file__).parent.resolve() / "nb_template.ipynb"
    )
    CONFIG_FILENAME = pathlib.Path(
        pathlib.Path(__file__).parent.resolve() / ".config_ipynb"
    )

    # instance attributes
    def __init__(self, dirpath):
        self.dirpath = pathlib.Path(dirpath)
        self.svg_path = None
        self.dot_path = None

    # instance method
    def build_graph(
        self,
        obj_state="run",
        full_json_path=None,
        add_separate_node=False,
        update=True,
        assets_to_add={},
    ):
        """
        creates a NetworkX graph representation of the GEMD relationships by reading every object
        generated by the GEMDEncoder object, storing all of its links by uid, and forming directed relationships,
        such as ingredient->process, or process->material
        It then allows filtering the objects mapped (i.e., removing spec or runs,
        measurements or ingredients) and saves a NetworkX graph in "dot" as .png

        :param dirpath: source of graph
        :param obj_state: to plot a graph of specs, runs or templates
        :param full_json_path: path to json file containing all objects in full format (!= )

        :return: graph
        """
        print(
            "-- Building {} in mode {} and with {}".format(
                self.dirpath, obj_state, add_separate_node
            )
        )
        G = nx.DiGraph()
        object_mapping = defaultdict()
        name_mapping = defaultdict()
        encoder = GEMDJson()
        nb_disregarded = 0

        gemd_objects = []
        if full_json_path:  # plotting a graph from a single, full json (!= thin)
            with open(full_json_path) as fp:
                # TODO: build gemd objects by converting them to thin jsons???
                object = encoder.load(fp)
        else:  # plotting a graph from a bunch of thin jsons
            gemd_objects = [
                os.path.join(dp, f)
                for dp, dn, filenames in os.walk(self.dirpath)
                for f in filenames
                if f.endswith(".json")
            ]
        if len(gemd_objects) == 0:
            return

        # adding objects to graph one by one
        for i, obj in enumerate(gemd_objects):
            if "raw_jsons" in obj:
                continue
            fp = open(obj, "r")
            obj_data = json.load(fp)
            obj_type = obj_data["type"]
            if (
                obj_type.startswith("parameter")
                or obj_type.startswith("condition")
                or obj_type.startswith("property")
            ):
                nb_disregarded += 1
                continue
            obj_uid = obj_data["uids"]["auto"]
            obj_name = obj_data["name"]
            name_mapping[obj_uid] = "{},  {}".format(obj_name, obj_uid[:3])
            self.handle_gemd_obj(
                G,
                obj_uid,
                obj_data,
                obj_type,
                obj_state,
                assets_to_add,
                add_separate_node,
            )
            if i % 1000 == 0:
                print("{} gemd objects processed...".format(i))

        # converting to grapviz
        relabeled_G = self.map_to_graphviz(G, name_mapping)

        # # plotting
        dot_path, svg_path = self.save_graph(
            self.dirpath, relabeled_G, name="{}_graph".format(obj_state)
        )
        if update:
            self.update_paths(svg_path, dot_path)

        # info
        self.diagnostics(G, gemd_objects, nb_disregarded)

        return G, relabeled_G, name_mapping

    def handle_gemd_obj(
        self,
        G,
        uid,
        obj_data,
        obj_type,
        obj_state,
        assets_to_add,
        add_separate_node,
    ):
        if obj_type.startswith("process"):
            if obj_type.endswith(obj_state):
                G.add_node(uid, color="red")
                self.add_gemd_assets(
                    G,
                    uid,
                    obj_data,
                    "process",
                    obj_state,
                    assets_to_add,
                    add_separate_node,
                )
        elif obj_type.startswith("ingredient"):  # TODO if node doesn't exist, create?
            if obj_type.endswith(obj_state):
                G.add_node(uid, color="blue")
                process = obj_data["process"]["id"]
                G.add_edge(uid, process)
                self.add_gemd_assets(
                    G,
                    uid,
                    obj_data,
                    "ingredient",
                    obj_state,
                    assets_to_add,
                    add_separate_node,
                )
                if "material" in obj_data and obj_data["material"]:
                    material = obj_data["material"]["id"]
                    G.add_edge(material, uid)
        elif obj_type.startswith("material"):
            if obj_type.endswith(obj_state):
                G.add_node(uid, color="green")
                self.add_gemd_assets(
                    G,
                    uid,
                    obj_data,
                    "material",
                    obj_state,
                    assets_to_add,
                    add_separate_node,
                )
                # if "process" in obj_data and obj_data["process"]:
                if obj_data["process"] and obj_data["process"]:
                    process = obj_data["process"]["id"]
                    G.add_edge(process, uid)  # ?
        elif obj_type.startswith("measurement"):
            if obj_type.endswith(obj_state):
                G.add_node(uid, color="purple")
                self.add_gemd_assets(
                    G,
                    uid,
                    obj_data,
                    "measurement",
                    obj_state,
                    assets_to_add,
                    add_separate_node,
                )
                if "material" in obj_data and obj_data["material"]:
                    material = obj_data["material"]["id"]
                    G.add_edge(uid, material)

    def add_gemd_assets(
        self,
        G,
        uid,
        obj_data,
        object_class,
        obj_state,
        assets_to_add,
        add_separate_node,
    ):
        if assets_to_add["add_attributes"] and "parameters" in obj_data:
            self.handle_gemd_value(G, uid, obj_data["parameters"], add_separate_node)
        if assets_to_add["add_attributes"] and "properties" in obj_data:
            self.handle_gemd_value(G, uid, obj_data["properties"], add_separate_node)
        if assets_to_add["add_attributes"] and "conditions" in obj_data:
            self.handle_gemd_value(G, uid, obj_data["conditions"], add_separate_node)
        if assets_to_add["add_file_links"] and "file_links" in obj_data:
            self.handle_gemd_value(G, uid, obj_data["file_links"], add_separate_node)
        if assets_to_add["add_tags"] and "tags" in obj_data:
            self.handle_gemd_value(G, uid, obj_data["tags"], add_separate_node)

    def handle_gemd_value(self, G, uid, assets, add_separate_node):
        # TODO: add pointing to templates?
        for att in assets:
            if type(att) in [str]:  # is a gemd tag
                if "::" in att:
                    self.add_to_graph(G, uid, att, "tags", add_separate_node=False)
            elif att["type"]:  # is a gemd object
                # reading gemd file links
                if att["type"] == "file_link":
                    self.add_to_graph(
                        G, uid, att["url"], "file_links", add_separate_node=False
                    )
                    continue
                # reading gemd attributes
                if att["type"] == "property_and_conditions":
                    value = att["property"]["value"]
                    att_name = att["property"]["name"]
                else:
                    value = att["value"]
                    att_name = att["name"]
                if value["type"] == "nominal_real":
                    node_name = "{}, {} {}".format(
                        att_name, value["nominal"], value["units"]
                    )
                elif value["type"] == "nominal_categorical":
                    node_name = "{}, {}".format(att_name, value["category"])
                self.add_to_graph(G, uid, node_name, att_name, add_separate_node)

    def add_to_graph(self, G, uid, node_name, att_name, add_separate_node):
        if add_separate_node == True:  # add as a separate node
            G.add_node(node_name, shape="rectangle", color="orange")
            G.add_edge(uid, node_name)
        else:  # add as an attribute of the node
            if att_name in G.nodes[uid].keys():  # already exists, append to it
                count = len(G.nodes[uid][att_name])
                G.nodes[uid][att_name][count] = node_name
                # if not type(G.nodes[uid][att_name]) == list:
                #     G.nodes[uid][att_name] = [G.nodes[uid][att_name]]
                # G.nodes[uid][att_name].append(node_name)
                return
            if att_name in ["file_links", "tags"]:
                G.nodes[uid][att_name] = {0: node_name}
            else:
                G.nodes[uid][att_name] = node_name

    def get_strongly_cc(self, G, node):
        """get strong connected component of node"""

        for cc in nx.strongly_connected_components(G):
            lst = []
            if node in cc:
                return cc
        else:
            return []

    def get_weakly_cc(self, G, node):
        """get weakly connected component of node"""
        for cc in nx.weakly_connected_components(G):
            if node in cc:
                return cc
        else:
            return []

    def diagnostics(self, G, gemd_objects, nb_disregarded):
        print("cycles in the graph: {}".format(list(nx.simple_cycles(G))))
        print(
            "nb of disregarded elements (i.e., templates/specs): {}/{}".format(
                nb_disregarded, len(gemd_objects)
            )
        )
        subgraphs = [G.subgraph(c).copy() for c in nx.strongly_connected_components(G)]
        print("number of connected components: {}".format(len(subgraphs)))
        print("nb of isolates: {}".format(nx.number_of_isolates(G)))

    @classmethod
    def launch_notebook(cls, dot_path):
        with open(cls.CONFIG_FILENAME, "w") as f:
            f.write(dot_path)
        os.system(
            "jupyter nbconvert --execute --to notebook --inplace  {}".format(
                cls.IPYNB_FILENAME
            )
        )
        os.system("jupyter notebook {}".format(cls.IPYNB_FILENAME))
        return None

    def update_paths(self, svg_path, dot_path):
        self.svg_path = svg_path
        self.dot_path = dot_path

    @classmethod
    def map_to_graphviz(cls, G, name_mapping=None):
        if name_mapping:
            G = nx.relabel_nodes(G, name_mapping)
        G = nx.nx_agraph.to_agraph(G)
        G.node_attr.update(nodesep=0.4)
        G.node_attr.update(ranksep=1)
        G.layout(prog="dot")
        return G

    @classmethod
    def slice_subgraph(cls, G, uuid, funcs, add_current=True):
        els = set()
        for func in funcs:
            els = els.union(func(G, uuid))
        if add_current:
            els.add(uuid)
        return G.subgraph(els)

    @classmethod
    def return_uuid(cls, identifier):
        return identifier

    @classmethod
    def extract_subgraph(cls, G, identifier, func):
        uuid = cls.return_uuid(identifier)
        return cls.slice_subgraph(G, uuid, func)

    @classmethod
    def save_graph(cls, dest, G, name):
        # svg file
        svg_path = os.path.join(dest, "{}.svg".format(name))
        # dot file
        dot_path = os.path.join(dest, "{}.dot".format(name))
        # writing svg file
        G.draw(svg_path)
        plt.close()
        # writing dot file
        with open(dot_path, "w") as f:
            f.write(str(G))
        print("Saved graph to {} and {}".format(dot_path, svg_path))
        return dot_path, svg_path

    @classmethod
    def build_parser(cls):
        """_summary_

        Returns:
            _type_: _description_
        """
        parser = argparse.ArgumentParser(
            prog="Gemd Viewer",
            description="Helps to visualize GEMD objects",
            epilog="primarly parses for path to folder of GEMD json files",
        )
        parser.add_argument("dirpath", help="path to folder of GEMD json files")
        parser.add_argument(
            "--identifier",
            type=str,
            help="identifier, typically uuid, but can also be passed as partial node name",
        )
        parser.add_argument(
            "--add_attributes",
            type=int,
            default=1,
            help="option to determine whether or not to add attributes (i.e., conditions,properties and parameters)",
        )
        parser.add_argument(
            "--add_tags",
            type=int,
            default=1,
            help="option to determine whether or not to add tags ",
        )
        parser.add_argument(
            "--add_file_links",
            type=int,
            # required=False,
            default=1,
            help="option to determine whether or not to add file links",
        )
        parser.add_argument(
            "--add_separate_node",
            action="store_true",
            help="option to add attributes, file links and tags as separate nodes on graph",
        )
        parser.add_argument(
            "--launch_notebook",
            action="store_true",
            help="triggers the launch of notebook to visualize your graph",
        )
        return parser

    @classmethod
    def run_from_command_line(cls, args=None):
        """
        Run a :class:`~GemdModeller` directly from the command line
        Calls :func:`~reconstruct` on a :class:`~GemdModeller` defined by
        command line (or given) arguments
        :param args: the list of arguments to send to the parser instead of getting them from sys.argv
        :type args: list, optional
        """
        parser = cls.build_parser()
        args = parser.parse_args(args=args)
        viewer = cls(args.dirpath)
        assets_to_add = {
            "add_attributes": args.add_attributes,
            "add_file_links": args.add_file_links,
            "add_tags": args.add_tags,
        }
        G, relabeled_G, name_mapping = viewer.build_graph(
            add_separate_node=args.add_separate_node, assets_to_add=assets_to_add
        )

        if args.identifier:
            identifier_G = cls.extract_subgraph(
                G, args.identifier, func=[nx.ancestors, nx.descendants]
            )
            identifier_G = cls.map_to_graphviz(identifier_G, name_mapping)
            identifier_G_dot_path, _ = cls.save_graph(
                viewer.dirpath, identifier_G, "{}".format(args.identifier)
            )

        if args.launch_notebook:
            if args.identifier:
                viewer.launch_notebook(identifier_G_dot_path)
            else:
                viewer.launch_notebook(viewer.dot_path)


def main(args=None):
    GemdModeller.run_from_command_line(args)


if __name__ == "__main__":
    main()
